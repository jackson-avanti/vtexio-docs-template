export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: any }> = { [K in keyof T]: T[K] };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  StringOrBoolean: any;
  IOSanitizedString: any;
  IOUpload: any;
  Upload: any;
};

export type AdditionalInfo = {
  __typename?: 'AdditionalInfo';
  key?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

export type Advertisement = {
  __typename?: 'Advertisement';
  /** ID of the ad item associated with the sponsored product. */
  adId?: Maybe<Scalars['ID']>;
  /** ID of the campaign owner of the ad item. */
  campaignId?: Maybe<Scalars['ID']>;
  /** Cost of the goal action. E.g: CPC, cost per click. */
  actionCost?: Maybe<Scalars['Float']>;
  /** Ad Request ID. */
  adRequestId?: Maybe<Scalars['ID']>;
  /** Ad Response ID. */
  adResponseId?: Maybe<Scalars['ID']>;
};

export type AssemblyOption = {
  __typename?: 'AssemblyOption';
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  required?: Maybe<Scalars['Boolean']>;
  composition?: Maybe<CompositionType>;
  inputValues?: Maybe<Array<Maybe<InputValue>>>;
};

export type AssemblyOptionInput = {
  id: Scalars['ID'];
  quantity: Scalars['Int'];
  assemblyId: Scalars['String'];
  seller: Scalars['String'];
  options?: Maybe<Array<AssemblyOptionInput>>;
};

export type Attachment = {
  __typename?: 'Attachment';
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  required?: Maybe<Scalars['Boolean']>;
  domainValues?: Maybe<Array<Maybe<DomainValues>>>;
};

export type Banners = {
  __typename?: 'Banners';
  /** List of banners. */
  banners?: Maybe<Array<Maybe<SearchBanner>>>;
};

/**  Benefit of a Product  */
export type Benefit = {
  __typename?: 'Benefit';
  /**  Flag which indicates if the benefit is featured or not  */
  featured?: Maybe<Scalars['Boolean']>;
  /**  Id of the product which the benefit is associated  */
  id?: Maybe<Scalars['String']>;
  /**  Name of the benefit  */
  name?: Maybe<Scalars['String']>;
  /**  Items of the benefit  */
  items?: Maybe<Array<Maybe<BenefitItem>>>;
  /**  Type of benefit  */
  teaserType?: Maybe<Scalars['String']>;
};

export type BenefitItem = {
  __typename?: 'BenefitItem';
  /**  Product itself  */
  benefitProduct?: Maybe<Product>;
  /**  IDs of the SKU Items that are taking part in the benefit  */
  benefitSKUIds?: Maybe<Array<Maybe<Scalars['String']>>>;
  /**  Discount applied to the benefit product  */
  discount?: Maybe<Scalars['Float']>;
  /**  Minimum quantity of the benefit product that is required to validate the benefit  */
  minQuantity?: Maybe<Scalars['Int']>;
};

export type Brand = {
  __typename?: 'Brand';
  /** slug is used as cacheId */
  cacheId?: Maybe<Scalars['ID']>;
  /** Brand id */
  id?: Maybe<Scalars['Int']>;
  /** Brand logo */
  imageUrl?: Maybe<Scalars['String']>;
  /** Text link */
  slug?: Maybe<Scalars['String']>;
  /** Name of brand */
  name?: Maybe<Scalars['String']>;
  /** Title used by html tag */
  titleTag?: Maybe<Scalars['String']>;
  /** Description used by html tag */
  metaTagDescription?: Maybe<Scalars['String']>;
  /** Brand is active */
  active?: Maybe<Scalars['Boolean']>;
};

export type BrandFacet = {
  __typename?: 'BrandFacet';
  id: Scalars['ID'];
  quantity: Scalars['Int'];
  name: Scalars['String'];
  link: Scalars['String'];
  linkEncoded: Scalars['String'];
  map?: Maybe<Scalars['String']>;
  value: Scalars['String'];
  selected: Scalars['Boolean'];
};

export type CategoriesTreeFacet = {
  __typename?: 'CategoriesTreeFacet';
  id: Scalars['ID'];
  quantity: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  link: Scalars['String'];
  linkEncoded: Scalars['String'];
  /** Contains slugified links according to the store structure. /:department/d, /:category/:subcategory, etc */
  href: Scalars['String'];
  map?: Maybe<Scalars['String']>;
  value: Scalars['String'];
  children?: Maybe<Array<Maybe<CategoriesTreeFacet>>>;
  selected: Scalars['Boolean'];
};

export type Category = {
  __typename?: 'Category';
  /**  id is used as cacheId  */
  cacheId?: Maybe<Scalars['ID']>;
  /**  URI of category  */
  href?: Maybe<Scalars['String']>;
  /**  Category text link  */
  slug?: Maybe<Scalars['String']>;
  /**  Category ID  */
  id?: Maybe<Scalars['Int']>;
  /**  Category name  */
  name?: Maybe<Scalars['String']>;
  /**  Title used by html tag */
  titleTag?: Maybe<Scalars['String']>;
  /**  Description used by html tag */
  hasChildren?: Maybe<Scalars['Boolean']>;
  /**  Has children categories  */
  metaTagDescription?: Maybe<Scalars['String']>;
  /**  Categories children  */
  children?: Maybe<Array<Maybe<Category>>>;
};

export type CategoryTreeBehavior = 
  /** Uses the default value set by the search provider */
  | 'default'
  /** Show the category tree when it is possible */
  | 'show'
  /** Hide the category tree in any situation */
  | 'hide';

export type ClusterHighlight = {
  __typename?: 'ClusterHighlight';
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
};

export type CompositionItem = {
  __typename?: 'CompositionItem';
  id?: Maybe<Scalars['ID']>;
  minQuantity?: Maybe<Scalars['Int']>;
  maxQuantity?: Maybe<Scalars['Int']>;
  initialQuantity?: Maybe<Scalars['Int']>;
  priceTable?: Maybe<Scalars['String']>;
  seller?: Maybe<Scalars['String']>;
};

export type CompositionType = {
  __typename?: 'CompositionType';
  minQuantity?: Maybe<Scalars['Int']>;
  maxQuantity?: Maybe<Scalars['Int']>;
  items?: Maybe<Array<Maybe<CompositionItem>>>;
};

export type Correction = {
  __typename?: 'Correction';
  correction?: Maybe<SearchCorrection>;
};

export type CrossSelingGroupByEnum = 
  /** It's the default behavior, it will group SKUs from the same product and bring only products. Limited by 12 products. */
  | 'PRODUCT'
  /** Return all skus registered in the catalog for the recommendation. */
  | 'NONE';

export type CrossSelingInputEnum = 
  | 'buy'
  | 'similars'
  | 'view'
  | 'viewAndBought'
  | 'accessories'
  | 'suggestions';

export type DeliverySlaPerTypes = {
  __typename?: 'DeliverySlaPerTypes';
  TypeName?: Maybe<Scalars['String']>;
  Price?: Maybe<Scalars['Float']>;
  EstimatedTimeSpanToDelivery?: Maybe<Scalars['String']>;
};

export type DeliverySlaSamples = {
  __typename?: 'DeliverySlaSamples';
  DeliverySlaPerTypes?: Maybe<Array<Maybe<DeliverySlaPerTypes>>>;
  Region?: Maybe<Region>;
};

export type DepartmentFacet = {
  __typename?: 'DepartmentFacet';
  id: Scalars['ID'];
  quantity: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  link: Scalars['String'];
  linkEncoded: Scalars['String'];
  map?: Maybe<Scalars['String']>;
  value: Scalars['String'];
  selected: Scalars['Boolean'];
};

/** Discount object */
export type Discount = {
  __typename?: 'Discount';
  /** Discount name */
  name?: Maybe<Scalars['String']>;
  /** Additional Info */
  additionalInfo?: Maybe<Array<Maybe<AdditionalInfo>>>;
};

export type DomainValues = {
  __typename?: 'DomainValues';
  FieldName?: Maybe<Scalars['String']>;
  MaxCaracters?: Maybe<Scalars['String']>;
  DomainValues?: Maybe<Scalars['String']>;
};

export type Facet = {
  __typename?: 'Facet';
  name?: Maybe<Scalars['String']>;
  values?: Maybe<Array<Maybe<FacetValue>>>;
  type?: Maybe<FilterType>;
  hidden?: Maybe<Scalars['Boolean']>;
  quantity?: Maybe<Scalars['Int']>;
};


export type FacetValuesArgs = {
  from?: Maybe<Scalars['Int']>;
  to?: Maybe<Scalars['Int']>;
};

export type Facets = {
  __typename?: 'Facets';
  /** @deprecated Use the `facets` instead. */
  departments?: Maybe<Array<Maybe<DepartmentFacet>>>;
  /** @deprecated Use the `facets` instead. */
  brands?: Maybe<Array<Maybe<BrandFacet>>>;
  specificationFilters?: Maybe<Array<Maybe<FilterFacets>>>;
  /** @deprecated Use the `facets` instead. */
  categoriesTrees?: Maybe<Array<Maybe<CategoriesTreeFacet>>>;
  /** Price range for the given query. */
  priceRanges?: Maybe<Array<Maybe<PriceRangesFacet>>>;
  /** @deprecated Use the recordsFiltered from the `productSearch` instead. */
  recordsFiltered?: Maybe<Scalars['Int']>;
  /** Info about the searched query. */
  queryArgs?: Maybe<QueryArgs>;
  /** List of facets. */
  facets?: Maybe<Array<Maybe<Facet>>>;
  /**
   * Indicates whether there was sampling in the aggregation of facets or not. In
   * search results that have many products, only the first 30000 will be
   * aggregated to avoid performance issues.
   */
  sampling?: Maybe<Scalars['Boolean']>;
  /** Generated breadcrumb for the given query. */
  breadcrumb?: Maybe<Array<Maybe<SearchBreadcrumb>>>;
};

export type FacetValue = {
  __typename?: 'FacetValue';
  id?: Maybe<Scalars['ID']>;
  quantity: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  key?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
  selected?: Maybe<Scalars['Boolean']>;
  children?: Maybe<Array<Maybe<FacetValue>>>;
  range?: Maybe<Range>;
  link?: Maybe<Scalars['String']>;
  linkEncoded?: Maybe<Scalars['String']>;
  href?: Maybe<Scalars['String']>;
};

export type FilterFacet = {
  __typename?: 'FilterFacet';
  quantity: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  link: Scalars['String'];
  linkEncoded: Scalars['String'];
  map?: Maybe<Scalars['String']>;
  value: Scalars['String'];
  selected: Scalars['Boolean'];
};

export type FilterFacets = {
  __typename?: 'FilterFacets';
  name?: Maybe<Scalars['String']>;
  facets?: Maybe<Array<Maybe<FilterFacet>>>;
};

export type FilterType = 
  | 'TEXT'
  | 'NUMBER'
  | 'CATEGORYTREE'
  | 'BRAND'
  | 'PRICERANGE';

export type GeneralValueTeaser = {
  __typename?: 'GeneralValueTeaser';
  key?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

export type Gift = {
  __typename?: 'Gift';
  productName?: Maybe<Scalars['String']>;
  skuName?: Maybe<Scalars['String']>;
  brand?: Maybe<Scalars['String']>;
  linkText?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  images?: Maybe<Array<Maybe<GiftImage>>>;
};

export type GiftImage = {
  __typename?: 'GiftImage';
  imageUrl?: Maybe<Scalars['String']>;
  imageLabel?: Maybe<Scalars['String']>;
  imageText?: Maybe<Scalars['String']>;
};

export type Image = {
  __typename?: 'Image';
  cacheId?: Maybe<Scalars['ID']>;
  imageId?: Maybe<Scalars['ID']>;
  imageLabel?: Maybe<Scalars['String']>;
  imageTag?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  imageText?: Maybe<Scalars['String']>;
};

export type InputValue = {
  __typename?: 'InputValue';
  label?: Maybe<Scalars['String']>;
  maxLength?: Maybe<Scalars['Int']>;
  type?: Maybe<InputValueType>;
  defaultValue?: Maybe<Scalars['StringOrBoolean']>;
  domain?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type InputValueType = 
  | 'TEXT'
  | 'BOOLEAN'
  | 'OPTIONS';

export type Installment = {
  __typename?: 'Installment';
  Value?: Maybe<Scalars['Float']>;
  InterestRate?: Maybe<Scalars['Float']>;
  TotalValuePlusInterestRate?: Maybe<Scalars['Float']>;
  NumberOfInstallments?: Maybe<Scalars['Int']>;
  PaymentSystemName?: Maybe<Scalars['String']>;
  PaymentSystemGroupName?: Maybe<Scalars['String']>;
  Name?: Maybe<Scalars['String']>;
};

export type InstallmentsCriteria = 
  | 'MAX_WITHOUT_INTEREST'
  | 'MAX_WITH_INTEREST'
  | 'MAX'
  | 'MIN'
  | 'ALL';



export type ItemMetadata = {
  __typename?: 'ItemMetadata';
  items?: Maybe<Array<Maybe<ItemMetadataUnit>>>;
  priceTable?: Maybe<Array<Maybe<ItemPriceTable>>>;
};

export type ItemMetadataUnit = {
  __typename?: 'ItemMetadataUnit';
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  skuName?: Maybe<Scalars['String']>;
  productId?: Maybe<Scalars['String']>;
  refId?: Maybe<Scalars['String']>;
  ean?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  detailUrl?: Maybe<Scalars['String']>;
  seller?: Maybe<Scalars['String']>;
  assemblyOptions?: Maybe<Array<Maybe<AssemblyOption>>>;
};

export type ItemPriceTable = {
  __typename?: 'ItemPriceTable';
  type?: Maybe<Scalars['String']>;
  values?: Maybe<Array<Maybe<PriceTableItem>>>;
};

export type Items = {
  __typename?: 'Items';
  thumb?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  href?: Maybe<Scalars['String']>;
  criteria?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  productId?: Maybe<Scalars['String']>;
};

export type ItemsFilter = 
  /** Returns all items, same as no filter. */
  | 'ALL'
  /** Returns only the first available item. Returns first if no item is available. */
  | 'FIRST_AVAILABLE'
  /** Returns all available items. Returns first if no item is available. */
  | 'ALL_AVAILABLE';

export type KitItem = {
  __typename?: 'KitItem';
  itemId?: Maybe<Scalars['ID']>;
  amount?: Maybe<Scalars['Int']>;
  product?: Maybe<OnlyProduct>;
  sku?: Maybe<Sku>;
};

export type Offer = {
  __typename?: 'Offer';
  Installments?: Maybe<Array<Maybe<Installment>>>;
  Price?: Maybe<Scalars['Float']>;
  ListPrice?: Maybe<Scalars['Float']>;
  spotPrice?: Maybe<Scalars['Float']>;
  PriceWithoutDiscount?: Maybe<Scalars['Float']>;
  RewardValue?: Maybe<Scalars['Float']>;
  PriceValidUntil?: Maybe<Scalars['String']>;
  AvailableQuantity?: Maybe<Scalars['Float']>;
  Tax?: Maybe<Scalars['Float']>;
  taxPercentage?: Maybe<Scalars['Float']>;
  CacheVersionUsedToCallCheckout?: Maybe<Scalars['String']>;
  DeliverySlaSamples?: Maybe<Array<Maybe<DeliverySlaSamples>>>;
  /** List of discount highlights */
  discountHighlights?: Maybe<Array<Discount>>;
  teasers?: Maybe<Array<Teaser>>;
  /** List of SKUs for gifts associated with the product */
  giftSkuIds?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** List of gifts associated with the product */
  gifts?: Maybe<Array<Maybe<Gift>>>;
};


export type OfferInstallmentsArgs = {
  criteria?: Maybe<InstallmentsCriteria>;
  rates?: Maybe<Scalars['Boolean']>;
  excludedPaymentSystems?: Maybe<Array<Maybe<Scalars['String']>>>;
  includedPaymentSystems?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type OnlyProduct = {
  __typename?: 'OnlyProduct';
  brand?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['ID']>;
  categoryTree?: Maybe<Array<Maybe<Category>>>;
  clusterHighlights?: Maybe<Array<Maybe<ClusterHighlight>>>;
  productClusters?: Maybe<Array<Maybe<ProductClusters>>>;
  description?: Maybe<Scalars['String']>;
  link?: Maybe<Scalars['String']>;
  linkText?: Maybe<Scalars['String']>;
  productId?: Maybe<Scalars['ID']>;
  productName?: Maybe<Scalars['String']>;
  properties?: Maybe<Array<Maybe<Property>>>;
  propertyGroups?: Maybe<Array<Maybe<PropertyGroup>>>;
  productReference?: Maybe<Scalars['String']>;
  recommendations?: Maybe<Recommendation>;
  jsonSpecifications?: Maybe<Scalars['String']>;
};

export type Operator = 
  | 'and'
  | 'or';

export type Options = {
  /** If the search has a redirect enabled, this allows (`true`) or not (`false`) the redirect to be used. */
  allowRedirect?: Maybe<Scalars['Boolean']>;
};

export type PageEntityIdentifier = 
  | 'brand'
  | 'department'
  | 'category'
  | 'subcategory'
  | 'search';

export type PageType = {
  __typename?: 'PageType';
  id?: Maybe<Scalars['String']>;
  type?: Maybe<PageEntityIdentifier>;
};

export type PriceRange = {
  __typename?: 'PriceRange';
  highPrice?: Maybe<Scalars['Float']>;
  lowPrice?: Maybe<Scalars['Float']>;
};

export type PriceRangesFacet = {
  __typename?: 'PriceRangesFacet';
  quantity: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  link: Scalars['String'];
  linkEncoded: Scalars['String'];
  map?: Maybe<Scalars['String']>;
  value: Scalars['String'];
  selected: Scalars['Boolean'];
  slug?: Maybe<Scalars['String']>;
};

export type PriceTableItem = {
  __typename?: 'PriceTableItem';
  id?: Maybe<Scalars['String']>;
  assemblyId?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Int']>;
};

export type Product = {
  __typename?: 'Product';
  /** Brand of the product */
  brand?: Maybe<Scalars['String']>;
  /** Id of the brand of the product */
  brandId?: Maybe<Scalars['Int']>;
  /** linkText is used as cacheId */
  cacheId?: Maybe<Scalars['ID']>;
  categoryId?: Maybe<Scalars['ID']>;
  /**
   * Categories of the product
   * @deprecated Use 'categoryTree' field for internationalization support
   */
  categories?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Product's categories */
  categoryTree?: Maybe<Array<Maybe<Category>>>;
  /** List of related products */
  clusterHighlights?: Maybe<Array<Maybe<ClusterHighlight>>>;
  productClusters?: Maybe<Array<Maybe<ProductClusters>>>;
  /** Product description */
  description?: Maybe<Scalars['String']>;
  /** SKU objects of the product */
  items?: Maybe<Array<Maybe<Sku>>>;
  /** List of SKU Specifications */
  skuSpecifications?: Maybe<Array<Maybe<SkuSpecification>>>;
  /** Product URL */
  link?: Maybe<Scalars['String']>;
  /** Product slug */
  linkText?: Maybe<Scalars['String']>;
  /** Product ID */
  productId?: Maybe<Scalars['ID']>;
  /** Product name */
  productName?: Maybe<Scalars['String']>;
  /** Array of product properties */
  properties?: Maybe<Array<Maybe<Property>>>;
  /** Array of product properties */
  propertyGroups?: Maybe<Array<Maybe<PropertyGroup>>>;
  /** Product reference */
  productReference?: Maybe<Scalars['String']>;
  /** Title used by html tag */
  titleTag?: Maybe<Scalars['String']>;
  /** Description used by html tag */
  metaTagDescription?: Maybe<Scalars['String']>;
  /** Related Products */
  recommendations?: Maybe<Recommendation>;
  /** JSON specification of the product */
  jsonSpecifications?: Maybe<Scalars['String']>;
  /** List of benefits associated with this product */
  benefits?: Maybe<Array<Maybe<Benefit>>>;
  itemMetadata?: Maybe<ItemMetadata>;
  /** Array of product SpecificationGroup */
  specificationGroups?: Maybe<Array<Maybe<SpecificationGroup>>>;
  /** Returns highest and lowest prices for available SKUs in product. */
  priceRange?: Maybe<ProductPriceRange>;
  /** Product Release Date, for list ordering and product cluster highlight */
  releaseDate?: Maybe<Scalars['String']>;
  /** Product properties that will be selected by default. e.g: {key: "Color", value: "Blue"} */
  selectedProperties?: Maybe<Array<Maybe<SelectedProperty>>>;
  /** Merchandising rule applied to the product */
  rule?: Maybe<Rule>;
  /** If this product is sponsored, ad information will be added here. */
  advertisement?: Maybe<Advertisement>;
};


export type ProductItemsArgs = {
  filter?: Maybe<ItemsFilter>;
};


export type ProductRecommendationsArgs = {
  groupBy?: Maybe<CrossSelingGroupByEnum>;
};

export type ProductClusters = {
  __typename?: 'ProductClusters';
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
};

export type ProductPriceRange = {
  __typename?: 'ProductPriceRange';
  sellingPrice?: Maybe<PriceRange>;
  listPrice?: Maybe<PriceRange>;
};

export type ProductSearch = {
  __typename?: 'ProductSearch';
  /** List of products. */
  products?: Maybe<Array<Maybe<Product>>>;
  /** Total number of products. */
  recordsFiltered?: Maybe<Scalars['Int']>;
  /** Title used in the title's tag. */
  titleTag?: Maybe<Scalars['String']>;
  /** String to be used in the `<meta name="description"...` tag. */
  metaTagDescription?: Maybe<Scalars['String']>;
  /** @deprecated Use the `breadcrumb` from the `facets` query instead. */
  breadcrumb?: Maybe<Array<Maybe<SearchBreadcrumb>>>;
  canonical?: Maybe<Scalars['String']>;
  /** @deprecated Use the `suggestion` query instead. */
  suggestion?: Maybe<SearchSuggestions>;
  /** Object that indicates if the term was misspelled and suggests a possible correction. */
  correction?: Maybe<SearchCorrection>;
  /**
   * Indicates how the search-engine dealt with the fullText when there is more
   * than one word.\n * `and` - It means that the products contains all the words
   * in the query.\n * `or` - It means that the results will contain at least one
   * word from the original search query. If `and` was not possible, `or` will be the fallback.
   */
  operator?: Maybe<Operator>;
  /**
   * Indicates how the search engine corrected the misspelled word by using fuzzy
   * logic. It can be a number representing the max number of misspelled letters,
   * or the string `auto` suggesting that the search-engine should set this value by itself.
   */
  fuzzy?: Maybe<Scalars['String']>;
  /**
   * As fuzzy and operator, it controls the search state, but it is for general
   * purposes. This field allows the search engines to apply features that are not
   * handled by the other fields.
   * The possible values in this field are defined by each search engine.
   */
  searchState?: Maybe<Scalars['String']>;
  /** @deprecated Use the `banners` query instead. */
  banners?: Maybe<Array<Maybe<SearchBanner>>>;
  /** Returns the redirect URL set for the given query. */
  redirect?: Maybe<Scalars['String']>;
};

export type ProductSpecification = {
  __typename?: 'productSpecification';
  fieldName?: Maybe<Scalars['String']>;
  fieldValues?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type ProductSuggestions = {
  __typename?: 'ProductSuggestions';
  /** Number of suggested products */
  count: Scalars['Int'];
  /** Suggested products */
  products: Array<Maybe<Product>>;
  /** If the term is misspelled or not */
  misspelled?: Maybe<Scalars['Boolean']>;
  /**
   * Indicates how the search-engine will deal with the fullText if there is more
   * than one word. Set `and` if the returned products must have all the words in
   * its metadata or `or` otherwise.
   */
  operator?: Maybe<Operator>;
};

export type ProductUniqueIdentifier = {
  field: ProductUniqueIdentifierField;
  value: Scalars['ID'];
};

export type ProductUniqueIdentifierField = 
  | 'id'
  | 'slug'
  | 'ean'
  | 'reference'
  | 'sku';

export type Property = {
  __typename?: 'Property';
  originalName?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  values?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type PropertyGroup = {
  __typename?: 'PropertyGroup';
  name?: Maybe<Scalars['String']>;
  properties?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type Query = {
  __typename?: 'Query';
  /** Returns a specified product */
  product?: Maybe<Product>;
  /**
   * Lists the banners registered for a given query. Check the [configuring banners documentation](https://help.vtex.com/en/tracks/vtex-intelligent-search--19wrbB7nEQcmwzDPl1l4Cb/4ViKEivLJtJsvpaW0aqIQ5)
   * for a full explanation of the banner feature.
   */
  banners?: Maybe<Banners>;
  /** Tries to correct a misspelled term from the search. */
  correction?: Maybe<Correction>;
  /** Lists suggested terms similar to the search term. */
  searchSuggestions?: Maybe<SearchSuggestions>;
  /** Lists the products for a given query. */
  productSearch?: Maybe<ProductSearch>;
  sponsoredProducts?: Maybe<Array<Maybe<Product>>>;
  searchMetadata?: Maybe<SearchMetadata>;
  /** Returns products list filtered and ordered */
  products?: Maybe<Array<Maybe<Product>>>;
  productRecommendations?: Maybe<Array<Maybe<Product>>>;
  productsByIdentifier?: Maybe<Array<Maybe<Product>>>;
  /** Returns facets category */
  facets?: Maybe<Facets>;
  /** Get auto complete suggestions in search */
  autocomplete?: Maybe<Suggestions>;
  /** Get list of the 10 most searched terms */
  topSearches?: Maybe<SearchSuggestions>;
  /** Lists the suggested terms and attributes similar to the search term. */
  autocompleteSearchSuggestions?: Maybe<SearchSuggestions>;
  /** Get product suggestions */
  productSuggestions?: Maybe<ProductSuggestions>;
  /** Get search urls access stats count */
  searchURLsCount?: Maybe<Array<Maybe<SearchUrlStats>>>;
};


export type QueryProductArgs = {
  slug?: Maybe<Scalars['String']>;
  identifier?: Maybe<ProductUniqueIdentifier>;
  regionId?: Maybe<Scalars['String']>;
  salesChannel?: Maybe<Scalars['Int']>;
};


export type QueryBannersArgs = {
  fullText?: Maybe<Scalars['String']>;
  selectedFacets?: Maybe<Array<Maybe<SelectedFacetInput>>>;
};


export type QueryCorrectionArgs = {
  fullText?: Maybe<Scalars['String']>;
};


export type QuerySearchSuggestionsArgs = {
  fullText: Scalars['String'];
};


export type QueryProductSearchArgs = {
  query?: Maybe<Scalars['String']>;
  fullText?: Maybe<Scalars['String']>;
  map?: Maybe<Scalars['String']>;
  selectedFacets?: Maybe<Array<Maybe<SelectedFacetInput>>>;
  category?: Maybe<Scalars['String']>;
  specificationFilters?: Maybe<Array<Maybe<Scalars['String']>>>;
  priceRange?: Maybe<Scalars['String']>;
  collection?: Maybe<Scalars['String']>;
  salesChannel?: Maybe<Scalars['String']>;
  orderBy?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['Int']>;
  to?: Maybe<Scalars['Int']>;
  hideUnavailableItems?: Maybe<Scalars['Boolean']>;
  simulationBehavior?: Maybe<SimulationBehavior>;
  productOriginVtex?: Maybe<Scalars['Boolean']>;
  operator?: Maybe<Operator>;
  fuzzy?: Maybe<Scalars['String']>;
  searchState?: Maybe<Scalars['String']>;
  options?: Maybe<Options>;
  variant?: Maybe<Scalars['String']>;
  showSponsored?: Maybe<Scalars['Boolean']>;
};


export type QuerySponsoredProductsArgs = {
  fullText?: Maybe<Scalars['String']>;
  selectedFacets?: Maybe<Array<Maybe<SelectedFacetInput>>>;
  priceRange?: Maybe<Scalars['String']>;
  salesChannel?: Maybe<Scalars['String']>;
  orderBy?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['Int']>;
  to?: Maybe<Scalars['Int']>;
  hideUnavailableItems?: Maybe<Scalars['Boolean']>;
  simulationBehavior?: Maybe<SimulationBehavior>;
  productOriginVtex?: Maybe<Scalars['Boolean']>;
  operator?: Maybe<Operator>;
  fuzzy?: Maybe<Scalars['String']>;
  searchState?: Maybe<Scalars['String']>;
  options?: Maybe<Options>;
  anonymousId?: Maybe<Scalars['String']>;
};


export type QuerySearchMetadataArgs = {
  query?: Maybe<Scalars['String']>;
  fullText?: Maybe<Scalars['String']>;
  map?: Maybe<Scalars['String']>;
  selectedFacets?: Maybe<Array<Maybe<SelectedFacetInput>>>;
};


export type QueryProductsArgs = {
  query?: Maybe<Scalars['String']>;
  map?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
  specificationFilters?: Maybe<Array<Maybe<Scalars['String']>>>;
  priceRange?: Maybe<Scalars['String']>;
  collection?: Maybe<Scalars['String']>;
  salesChannel?: Maybe<Scalars['String']>;
  orderBy?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['Int']>;
  to?: Maybe<Scalars['Int']>;
  hideUnavailableItems?: Maybe<Scalars['Boolean']>;
  simulationBehavior?: Maybe<SimulationBehavior>;
  shippingOptions?: Maybe<Array<Maybe<Scalars['String']>>>;
  variant?: Maybe<Scalars['String']>;
};


export type QueryProductRecommendationsArgs = {
  identifier?: Maybe<ProductUniqueIdentifier>;
  type?: Maybe<CrossSelingInputEnum>;
  groupBy?: Maybe<CrossSelingGroupByEnum>;
};


export type QueryProductsByIdentifierArgs = {
  field: ProductUniqueIdentifierField;
  values?: Maybe<Array<Scalars['ID']>>;
  salesChannel?: Maybe<Scalars['String']>;
};


export type QueryFacetsArgs = {
  query?: Maybe<Scalars['String']>;
  fullText?: Maybe<Scalars['String']>;
  map?: Maybe<Scalars['String']>;
  selectedFacets?: Maybe<Array<Maybe<SelectedFacetInput>>>;
  hideUnavailableItems?: Maybe<Scalars['Boolean']>;
  removeHiddenFacets?: Maybe<Scalars['Boolean']>;
  behavior?: Maybe<Scalars['String']>;
  operator?: Maybe<Operator>;
  fuzzy?: Maybe<Scalars['String']>;
  searchState?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['Int']>;
  to?: Maybe<Scalars['Int']>;
  categoryTreeBehavior?: Maybe<CategoryTreeBehavior>;
  initialAttributes?: Maybe<Scalars['String']>;
};


export type QueryAutocompleteArgs = {
  maxRows?: Maybe<Scalars['Int']>;
  searchTerm?: Maybe<Scalars['String']>;
};


export type QueryAutocompleteSearchSuggestionsArgs = {
  fullText: Scalars['String'];
};


export type QueryProductSuggestionsArgs = {
  fullText: Scalars['String'];
  facetKey?: Maybe<Scalars['String']>;
  facetValue?: Maybe<Scalars['String']>;
  productOriginVtex?: Maybe<Scalars['Boolean']>;
  simulationBehavior?: Maybe<SimulationBehavior>;
  hideUnavailableItems?: Maybe<Scalars['Boolean']>;
  regionId?: Maybe<Scalars['String']>;
  salesChannel?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  shippingOptions?: Maybe<Array<Maybe<Scalars['String']>>>;
  variant?: Maybe<Scalars['String']>;
};


export type QuerySearchUrLsCountArgs = {
  limit?: Maybe<Scalars['Int']>;
  sort?: Maybe<Sort>;
};

export type QueryArgs = {
  __typename?: 'QueryArgs';
  map?: Maybe<Scalars['String']>;
  query?: Maybe<Scalars['String']>;
  selectedFacets?: Maybe<Array<Maybe<SelectedFacet>>>;
};

export type Range = {
  __typename?: 'Range';
  from?: Maybe<Scalars['Float']>;
  to?: Maybe<Scalars['Float']>;
};

export type Recommendation = {
  __typename?: 'Recommendation';
  buy?: Maybe<Array<Maybe<Product>>>;
  view?: Maybe<Array<Maybe<Product>>>;
  similars?: Maybe<Array<Maybe<Product>>>;
};

export type Reference = {
  __typename?: 'Reference';
  Key?: Maybe<Scalars['String']>;
  Value?: Maybe<Scalars['String']>;
};

export type Region = {
  __typename?: 'Region';
  IsPersisted?: Maybe<Scalars['Boolean']>;
  IsRemoved?: Maybe<Scalars['Boolean']>;
  Id?: Maybe<Scalars['ID']>;
  Name?: Maybe<Scalars['String']>;
  CountryCode?: Maybe<Scalars['String']>;
  ZipCode?: Maybe<Scalars['String']>;
  CultureInfoName?: Maybe<Scalars['String']>;
};

export type Rule = {
  __typename?: 'Rule';
  id?: Maybe<Scalars['String']>;
};

export type SearchBanner = {
  __typename?: 'SearchBanner';
  /** Banner ID. */
  id?: Maybe<Scalars['String']>;
  /** Banner name. */
  name?: Maybe<Scalars['String']>;
  /** Banner area. */
  area?: Maybe<Scalars['String']>;
  /** Banner HTML. */
  html?: Maybe<Scalars['String']>;
};

export type SearchBreadcrumb = {
  __typename?: 'SearchBreadcrumb';
  /** Human-readable format of the facet key. */
  name?: Maybe<Scalars['String']>;
  /** Query link. */
  href?: Maybe<Scalars['String']>;
};

/** Object that indicates if the term was misspelled and suggests a possible correction. */
export type SearchCorrection = {
  __typename?: 'SearchCorrection';
  /** The corrected term. If the API was not able to correct the term, it will show the original search term. */
  text?: Maybe<Scalars['String']>;
  /** The same as `text`, but it highlights the corrected word. Useful when there is more than one word. */
  highlighted?: Maybe<Scalars['String']>;
  /** Whether the term was misspelled (`true`) or not (`false`). */
  misspelled?: Maybe<Scalars['Boolean']>;
  /** Whether the API was able to suggest a correction (`true`) or not (`false`). */
  correction?: Maybe<Scalars['Boolean']>;
};

export type SearchMetadata = {
  __typename?: 'SearchMetadata';
  titleTag?: Maybe<Scalars['String']>;
  metaTagDescription?: Maybe<Scalars['String']>;
};

export type SearchSuggestion = {
  __typename?: 'SearchSuggestion';
  /** Search term. */
  term: Scalars['String'];
  /** Number of times the term was searched. */
  count: Scalars['Int'];
  /** List of facets in which the term can be searched. */
  attributes?: Maybe<Array<Maybe<SearchSuggestionAttribute>>>;
};

export type SearchSuggestionAttribute = {
  __typename?: 'SearchSuggestionAttribute';
  /** Facet key. */
  key: Scalars['String'];
  /** Facet value. */
  value: Scalars['String'];
  /** Human-readable format of the facet key. */
  labelValue: Scalars['String'];
};

export type SearchSuggestions = {
  __typename?: 'SearchSuggestions';
  /** A list of search suggestions. */
  searches?: Maybe<Array<Maybe<SearchSuggestion>>>;
};

export type SearchUrlStats = {
  __typename?: 'SearchURLStats';
  path: Scalars['String'];
  count: Scalars['Int'];
};

export type SelectedFacet = {
  __typename?: 'SelectedFacet';
  key?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

export type SelectedFacetInput = {
  /** Facet key. */
  key?: Maybe<Scalars['String']>;
  /** Facet value. */
  value?: Maybe<Scalars['String']>;
};

export type SelectedProperty = {
  __typename?: 'SelectedProperty';
  key?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

export type Seller = {
  __typename?: 'Seller';
  sellerId?: Maybe<Scalars['ID']>;
  sellerName?: Maybe<Scalars['String']>;
  addToCartLink?: Maybe<Scalars['String']>;
  sellerDefault?: Maybe<Scalars['Boolean']>;
  commertialOffer?: Maybe<Offer>;
};

export type SimulationBehavior = 
  /** Does simulation on catalog as usual */
  | 'default'
  /** Does simulation on catalog only for seller 1P */
  | 'only1P'
  /** Calls catalog passing a parameter to not simulate each SKU and get its most up to date price. */
  | 'skip'
  /** Does the simulation on the client side */
  | 'async';

export type Sku = {
  __typename?: 'SKU';
  itemId?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  nameComplete?: Maybe<Scalars['String']>;
  complementName?: Maybe<Scalars['String']>;
  ean?: Maybe<Scalars['String']>;
  referenceId?: Maybe<Array<Maybe<Reference>>>;
  measurementUnit?: Maybe<Scalars['String']>;
  unitMultiplier?: Maybe<Scalars['Float']>;
  kitItems?: Maybe<Array<Maybe<KitItem>>>;
  images?: Maybe<Array<Maybe<Image>>>;
  videos?: Maybe<Array<Maybe<Video>>>;
  sellers?: Maybe<Array<Maybe<Seller>>>;
  variations?: Maybe<Array<Maybe<Property>>>;
  /** @deprecated Use itemMetaData instead */
  attachments?: Maybe<Array<Maybe<Attachment>>>;
  estimatedDateArrival?: Maybe<Scalars['String']>;
};


export type SkuImagesArgs = {
  quantity?: Maybe<Scalars['Int']>;
};

export type SkuSpecification = {
  __typename?: 'SkuSpecification';
  field?: Maybe<SkuSpecificationField>;
  values?: Maybe<Array<Maybe<SkuSpecificationValue>>>;
};

export type SkuSpecificationField = {
  __typename?: 'SKUSpecificationField';
  originalName?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

export type SkuSpecificationValue = {
  __typename?: 'SKUSpecificationValue';
  originalName?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

export type Sort = 
  | 'ASC'
  | 'DESC';

export type SpecificationGroup = {
  __typename?: 'SpecificationGroup';
  originalName?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  specifications?: Maybe<Array<Maybe<SpecificationGroupProperty>>>;
};

export type SpecificationGroupProperty = {
  __typename?: 'SpecificationGroupProperty';
  originalName?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  values?: Maybe<Array<Maybe<Scalars['String']>>>;
};


export type Suggestions = {
  __typename?: 'Suggestions';
  /**  searchTerm from Query autocomplete is used as cacheId  */
  cacheId?: Maybe<Scalars['ID']>;
  itemsReturned?: Maybe<Array<Maybe<Items>>>;
};

export type Teaser = {
  __typename?: 'Teaser';
  name?: Maybe<Scalars['String']>;
  conditions?: Maybe<TeaserCondition>;
  effects?: Maybe<TeaserEffects>;
  generalValues?: Maybe<Array<Maybe<GeneralValueTeaser>>>;
};

export type TeaserCondition = {
  __typename?: 'TeaserCondition';
  minimumQuantity?: Maybe<Scalars['Int']>;
  parameters?: Maybe<Array<Maybe<TeaserValue>>>;
};

export type TeaserEffects = {
  __typename?: 'TeaserEffects';
  parameters?: Maybe<Array<Maybe<TeaserValue>>>;
};

export type TeaserValue = {
  __typename?: 'TeaserValue';
  name?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};


export type Video = {
  __typename?: 'Video';
  videoUrl?: Maybe<Scalars['String']>;
};

export {}