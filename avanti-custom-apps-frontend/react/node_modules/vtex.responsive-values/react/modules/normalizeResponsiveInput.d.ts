/** The user is able to input `mobile` as a device (as opposed to `desktop`),
 * but the output will be converted to `phone` and `tablet` */
import type { InputDevice, OutputDevice } from '../ResponsiveValuesTypes';
export declare type ResponsiveInput<T> = Record<InputDevice | string, T>;
export declare type MaybeResponsiveInput<T> = T | ResponsiveInput<T>;
export declare type NormalizedInput<T> = {
    devices: Record<OutputDevice, T>;
    queries: Record<string, T>;
};
/** Checks if the input value is a ResponsiveInput type (an object with
 * one or more keys of Device type--e.g. `desktop`, `mobile`) */
export declare const isResponsiveInput: <T>(value: any) => value is Record<string, T>;
/** Takes an input that might be a responsive object or not
 * (i.e. either "prop: {mobile: 1, desktop:2}" or just "prop: 2")
 * and returns an object of the values broken down into devices
 * (i.e. {phone: 1, tablet: 1, desktop: 2})
 *
 * TODO: this can return undefined if only media queries are defined
 * should we add undefined to the return type of our hooks?
 * it would make it a bit annoying to use, but probably safer
 */
export declare const normalizeResponsiveInput: <T>(input: MaybeResponsiveInput<T>) => NormalizedInput<T>;
export declare const normalizeResponsiveInputs: <Input extends Record<string, unknown>>(input: Input) => {
    inputList: [keyof Input, NormalizedInput<unknown>][];
    queryList: string[];
};
